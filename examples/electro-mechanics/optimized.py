# # Optimized code for the electro-mechanics example
#
# In this example we will take the monolithic model and optimize it so that it runs faster. To do this we will to two things:
#
# 1. We will use the `numba` library to compile the functions generated by `gotranx` to machine code.
# 2. We will use the `sympy` library to generate the stress function and compile it to machine code using `numba`.
#
# Note that this example uses `numba` which you need to install to run the code. You can install it using `pip install numba`.

from textwrap import dedent
import sys
from pathlib import Path
from tqdm import tqdm
import gotranx
from scipy.optimize import root
import numpy as np
import matplotlib.pyplot as plt
import sympy as sp
import zero_mech

try:
    import numba
except ImportError:

    class numba:  # type: ignore
        def jit(*args, **kwargs):
            def decorator(f):
                return f

            return decorator

# First we create the experiment, material, compressibility and active stress models. Note that we create a new variable for $\lambda$ which doesn't use unicode characters. This is because `numba` doesn't support unicode characters in variable names.

experiment = zero_mech.experiments.uniaxial_tension(lmbda=sp.Symbol("lmbda", real=True, positive=True))
mat = zero_mech.material.NeoHookean()
comp = zero_mech.compressibility.Incompressible()
act = zero_mech.active.ActiveStress()
mech_model = zero_mech.Model(material=mat, compressibility=comp, active=act)

# First Piola-Kirchhoff stress
P = mech_model.first_piola_kirchhoff(experiment.F)


# When generating the gotranx code we also specify the shape of the values, in this case we use `gotranx.codegen.base.Shape.single` which means that the generated code will expect scalar values. This is important for the `numba` compilation.

# Generate code and save it to a file if it does not exist
module_path = Path("ToRORd_dynCl_endo_optimized.py")
if not module_path.is_file():
    ode = gotranx.load_ode("ToRORd_dynCl_endo.ode")
    code = gotranx.cli.gotran2py.get_code(
        ode, scheme=[gotranx.schemes.Scheme.generalized_rush_larsen],
        shape=gotranx.codegen.base.Shape.single,
    )
    module_path.write_text(code)

import ToRORd_dynCl_endo_optimized

model = ToRORd_dynCl_endo_optimized.__dict__


# Now we can use the model dictionary to call the generated functions

# Set time step to 0.1 ms
dt = 0.1
# Simulate model for 1000 ms
BCL = 500
num_beats = 10
t = np.arange(0, BCL, dt)

# We just need to the set stimulus period to a number longer than the BCL to avoid the stimulus.

y = model["init_state_values"]()
# Get initial parameter values
params = model["init_parameter_values"](i_Stim_Period=BCL * 2)

# Now let us apply the jit compilation to the functions we will use in the simulation.

# Get the index of the membrane potential
V_index = model["state_index"]("v")
Ca_index = model["state_index"]("cai")
# Get the index of the active tension from the land model
Ta_index = model["monitor_index"]("Ta")
Istim_index = model["monitor_index"]("Istim")
fgr = numba.jit(nopython=True)(model["generalized_rush_larsen"])
mon = numba.jit(nopython=True)(model["monitor_values"])
lmbda_index = model["parameter_index"]("lmbda")
dLambda_index = model["parameter_index"]("dLambda")

# Now we will generate the stress function using `sympy` and compile it using `numba`. Here we utilize the code printer in `sympy` to generate the code for the stress function. This is actually how `gotranx` also work under the hood.

# Define the stress function and compile it
matkeys = ",".join(map(str, mat.default_parameters().keys()))
code = dedent(f"""
import numpy as np

def stress(p, Ta, lmbda, {matkeys}):

    P11 = {sp.printing.pycode(P[0,0]).replace('math', 'np')}
    P22 = {sp.printing.pycode(P[1,1]).replace('math', 'np')}
    return np.array([P11, P22], dtype=np.float64)
""")

# We execute the code in a namespace (or dictionary) and then compile the `stress` function using `numba`.

ns = {}
exec(code, ns)
stress = numba.jit(nopython=True)(ns["stress"])
material_params = {str(k): v for k, v in mat.default_parameters().items()}
mu = material_params["mu"]


# Now we update the function for the root finding to use this new stress function. We also jit this function.

@numba.jit(nopython=True)
def func(x, y, ti, dt, params, new_y, prev_lmbda):
    lmbda, p = x
    dLambda = (lmbda - prev_lmbda) / dt

    # Update lmbda and dLambda in the model
    params[lmbda_index] = lmbda
    params[dLambda_index] = dLambda
    new_y[:] = fgr(y, ti, dt, params)
    monitor = mon(ti, new_y, params)
    Ta = monitor[Ta_index]

    return stress(
            p,
            Ta,
            lmbda,
            mu=mu
        )


# Now we are ready to initialize the problem and solve it for each beat. We will store the results in arrays and plot them afterwards.

lmbda_value = 1.0
p_value = 0.0
params[lmbda_index] = lmbda_value
prev_lmbda = lmbda_value
params[dLambda_index] = 0.0

N = len(t)
V = np.zeros(N * num_beats)
Ca = np.zeros(N * num_beats)
Ta = np.zeros(N * num_beats)
Istim = np.zeros(N * num_beats)
lmbdas = np.zeros(N * num_beats)
dLambdas = np.zeros(N * num_beats)
ps = np.zeros(N * num_beats)

for beat in range(num_beats):
    for i, ti in tqdm(enumerate(t), total=N, file=sys.stdout, desc=f"Beat {beat+1}/{num_beats}"):
        # # Calculate lambda and p using root finding
        res = root(
            func,
            np.array([lmbda_value, p_value]),
            args=(y.copy(), ti, dt, params, y, prev_lmbda),
            method="hybr",
        )
        lmbda_value, p_value = res.x
        V[beat*N + i] = y[V_index]
        Ca[beat*N + i] = y[Ca_index]
        monitor = mon(ti, y, params)
        Ta[beat*N + i] = monitor[Ta_index]
        lmbdas[beat*N + i] = lmbda_value
        ps[beat*N + i] = p_value

        dLambda = (lmbda_value - prev_lmbda) / dt
        dLambdas[beat*N + i] = dLambda

        prev_lmbda = lmbda_value
        Istim[beat*N + i] = monitor[Istim_index]


# And plot the results
fig, ax = plt.subplots(2, 3, sharex=True)
ax[0, 0].plot(t, V[-N:])
ax[1, 0].plot(t, Ta[-N:])
ax[0, 1].plot(t, Ca[-N:])
ax[1, 1].plot(t, dLambdas[-N:])
ax[0, 2].plot(t, lmbdas[-N:])
ax[1, 2].plot(t, ps[-N:])
ax[1, 0].set_xlabel("Time (ms)")
ax[1, 1].set_xlabel("Time (ms)")
ax[0, 0].set_ylabel("V (mV)")
ax[1, 0].set_ylabel("Ta (kPa)")
ax[0, 1].set_ylabel("Ca (mM)")
ax[1, 1].set_ylabel("dLambda")
ax[0, 2].set_ylabel("Lambda")
ax[1, 2].set_ylabel("p")
for axi in ax.flatten():
    axi.grid()
fig.tight_layout()
fig.savefig("neohookean_monolithic_optimized_last_beat.png")


fig, ax = plt.subplots(2, 3, sharex=True)
ax[0, 0].plot(V)
ax[1, 0].plot(Ta)
ax[0, 1].plot(Ca)
ax[1, 1].plot(dLambdas)
ax[0, 2].plot(lmbdas)
ax[1, 2].plot(ps)
ax[1, 0].set_xlabel("Time (ms)")
ax[1, 1].set_xlabel("Time (ms)")
ax[0, 0].set_ylabel("V (mV)")
ax[1, 0].set_ylabel("Ta (kPa)")
ax[0, 1].set_ylabel("Ca (mM)")
ax[1, 1].set_ylabel("dLambda")
ax[0, 2].set_ylabel("Lambda")
ax[1, 2].set_ylabel("p")
for axi in ax.flatten():
    axi.grid()
fig.tight_layout()
fig.savefig("neohookean_monolithic_optimized_all_beats.png")
